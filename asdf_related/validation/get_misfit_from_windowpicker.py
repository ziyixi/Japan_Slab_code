"""
Calculate misfit for data and sync asdf pairs, using the windows from WindowPicker.
"""
import numpy as np
import click
import obspy
import pyasdf
from collections import namedtuple
from obspy.signal.cross_correlation import correlate, xcorr_max
from multiprocessing import Pool
import tqdm
from functools import partial
import pickle
import click

win = namedtuple("win", ["gcarc", "comp", "p", "s", "pp", "ss",
                         "sp", "scs", "rayleigh", "love"])

# some constants
PADDING = 0


def str2num(x):
    if(x == "None"):
        return None
    else:
        return float(x)


def read_window_file(win_fname):
    """
    Read window files generated by WindowPicker (simplified)
    """
    data = np.loadtxt(win_fname, dtype=np.str)
    comp = None
    result = {}
    for row in data:
        if(row[2] == "vertical"):
            comp = 2
        elif(row[2] == "radial"):
            comp = 0
        elif(row[2] == "tangential"):
            comp = 1
        else:
            raise Exception("comp has problems!")

        gcarc = str2num(row[1])
        p = (str2num(row[3]), str2num(row[4]))
        s = (str2num(row[5]), str2num(row[6]))
        pp = (str2num(row[7]), str2num(row[8]))
        ss = (str2num(row[9]), str2num(row[10]))
        sp = (str2num(row[11]), str2num(row[12]))
        scs = (str2num(row[13]), str2num(row[14]))
        rayleigh = (str2num(row[15]), str2num(row[16]))
        love = (str2num(row[17]), str2num(row[18]))

        result[(row[0], comp)] = win(gcarc, comp, p, s, pp, ss,
                                     sp, scs, rayleigh, love)

    return result


def read_asdf_files(data_fname, sync_fname):
    data_asdf = pyasdf.ASDFDataSet(data_fname, mode="r")
    sync_asdf = pyasdf.ASDFDataSet(sync_fname, mode="r")
    return data_asdf, sync_asdf


def cal_waveform_similarity_deltat(tr_data, tr_sync, starttime, endtime):
    """
    Assume here we already have data and sync's traces matched.
    """
    if(starttime == None or endtime == None):
        return None, None
    con1 = (tr_data.stats.starttime > starttime-PADDING) or (
        tr_data.stats.endtime < endtime+PADDING)
    con2 = (tr_sync.stats.starttime > starttime) or (
        tr_sync.stats.endtime < endtime)
    if(con1 or con2):
        return None, None
    cc_data = tr_data.slice(starttime-PADDING, endtime+PADDING)
    cc_sync = tr_sync.slice(starttime, endtime)
    cc = correlate(cc_data, cc_sync, None, demean=False)

    similarity = cc[len(cc)//2]
    max_cc_pos, max_cc = xcorr_max(cc, abs_max=False)
    delta = tr_data.stats.delta
    deltat = delta*max_cc_pos

    return similarity, deltat


def get_tags(data_asdf, sync_asdf):
    data_all_stations = data_asdf.waveforms.list()
    sync_all_stations = sync_asdf.waveforms.list()
    data_representative = data_all_stations[0]
    sync_representative = sync_all_stations[0]
    data_tag = data_asdf.waveforms[data_representative].get_waveform_tags()[0]
    sync_tag = sync_asdf.waveforms[sync_representative].get_waveform_tags()[0]
    return data_tag, sync_tag


def kernel(kernel_info,  event_time=None):
    # here the kcomp is just a number labeled as: 0 R 1 T 2 Z
    net_sta, comp, win_info, tr_data_st, tr_sync_st = kernel_info
    tr_data = tr_data_st[comp]
    tr_sync = tr_sync_st[comp]
    # here the win_info is just a win tuple, we use the same tuple to output the result
    # the processing scripts has already cut the starttime of the data and sync as the event time
    # p
    p = cal_waveform_similarity_deltat(
        tr_data, tr_sync, win_info.p[0]+event_time, win_info.p[1]+event_time)
    # s
    s = cal_waveform_similarity_deltat(
        tr_data, tr_sync, win_info.s[0]+event_time, win_info.s[1]+event_time)
    # pp
    pp = cal_waveform_similarity_deltat(
        tr_data, tr_sync, win_info.pp[0]+event_time, win_info.pp[1]+event_time)
    # ss
    ss = cal_waveform_similarity_deltat(
        tr_data, tr_sync, win_info.ss[0]+event_time, win_info.ss[1]+event_time)
    # sp
    sp = cal_waveform_similarity_deltat(
        tr_data, tr_sync, win_info.sp[0]+event_time, win_info.sp[1]+event_time)
    # scs
    scs = cal_waveform_similarity_deltat(
        tr_data, tr_sync, win_info.scs[0]+event_time, win_info.scs[1]+event_time)
    # rayleigh
    rayleigh = cal_waveform_similarity_deltat(
        tr_data, tr_sync, win_info.rayleigh[0]+event_time, win_info.rayleigh[1]+event_time)
    # love
    love = cal_waveform_similarity_deltat(
        tr_data, tr_sync, win_info.love[0]+event_time, win_info.love[1]+event_time)
    return (net_sta, comp, win(win_info.gcarc, win_info.comp, p, s, pp, ss, sp, scs, rayleigh, love))


def save_result(theresult, output_fname):
    """
    save the result to the pickle file.
    """
    # firstly, convert to the dict
    dict_result = {}
    for item in theresult:
        net_sta, comp, thewin = item
        dict_result[(net_sta, comp)] = thewin
    with open(output_fname, 'wb') as handle:
        pickle.dump(dict_result, handle, protocol=pickle.HIGHEST_PROTOCOL)


@click.command()
@click.option('--data_fname', required=True, type=str)
@click.option('--sync_fname', required=True, type=str)
@click.option('--win_fname', required=True, type=str)
@click.option('--output_fname', required=True, type=str)
def main(data_fname, sync_fname, win_fname, output_fname):
    """
    3 components in 3 different files, should be ordered by the gcarc. (since dict in new Python has the order)
    """
    # * for each key, find the corresponding waveform in asdf files, and then align them.
    # get tags
    data_asdf, sync_asdf = read_asdf_files(data_fname, sync_fname)
    data_tag, sync_tag = get_tags(data_asdf, sync_asdf)
    # get win file
    event = data_asdf.events[0]
    origin = event.preferred_origin() or event.origins[0]
    event_time = origin.time
    # the key of the windows will be (net_sta,comp)
    windows = read_window_file(win_fname)

    kernel_result = None
    partialed_kernel = partial(
        kernel,  event_time=event_time)

    kernel_info_list = []
    for thekey in windows:
        tr_data = data_asdf.waveforms[thekey[0]][data_tag]
        tr_sync = sync_asdf.waveforms[thekey[0]][sync_tag]
        kernel_info_list.append(
            (thekey[0], thekey[1], windows[thekey]), tr_data, tr_sync)

    with Pool(48) as p:
        kernel_result = list(tqdm.tqdm(
            p.imap(partialed_kernel, kernel_info_list), total=len(kernel_info_list)))

    # save the result
    save_result(kernel_result)


if __name__ == "__main__":
    main()
